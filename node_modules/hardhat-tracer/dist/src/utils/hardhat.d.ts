import { Address } from "@nomicfoundation/ethereumjs-util";
import { HardhatRuntimeEnvironment } from "hardhat/types";
import { MinimalEthereumJsVm } from "hardhat/internal/hardhat-network/provider/vm/minimal-vm";
import { EdrProviderWrapper } from "hardhat/internal/hardhat-network/provider/provider";
import { MinimalExecResult } from "hardhat/internal/hardhat-network/provider/vm/types";
export declare function getVMFromBaseProvider(provider: EdrProviderWrapper): Promise<MinimalEthereumJsVm>;
/**
 * Finds the "base" Ethereum provider of the current hardhat environment.
 *
 * Basically, hardhat uses a system of nested providers where each provider wraps the next and
 * "provides" some extra features. When you're running on top of the "hardhat evm" the bottom of
 * this series of providers is the "HardhatNetworkProvider":
 * https://github.com/nomiclabs/hardhat/blob/master/packages/hardhat-core/src/internal/hardhat-network/provider/provider.ts
 * This object has direct access to the node (provider._node), which in turn has direct access to
 * the ethereumjs-vm instance (provider._node._vm). So it's quite useful to be able to find this
 * object reliably!
 *
 * @param hre hardhat runtime environment to pull the base provider from.
 * @return base hardhat network provider
 */
export declare const getHardhatBaseProvider: (runtime: HardhatRuntimeEnvironment) => Promise<EdrProviderWrapper>;
/**
 * Converts a string into the fancy new address thing that ethereumjs-vm v6 expects
 *
 * @param address String address to convert into the fancy new address type.
 * @returns Fancified address.
 */
export declare const toFancyAddress: (address: string) => Address;
/**
 * Same as toFancyAddress but in the opposite direction.
 *
 * @param fancyAddress Fancy address to turn into a string.
 * @returns Way more boring address.
 */
export declare const fromFancyAddress: (fancyAddress: Address) => string;
/**
 * Parses the result of an execution to be usable easily.
 * @param execResult
 * @returns Parsed exec result
 */
export declare function parseExec(execResult: MinimalExecResult): {
    reason: import("@nomicfoundation/edr").SuccessReason | import("@nomicfoundation/edr").ExceptionalHalt | undefined;
    success: boolean;
    isStop: boolean;
    isReturn: boolean;
    isSelfDestruct: boolean;
    isRevert: boolean;
    isException: boolean;
    isOutOfGas: boolean;
    isOpcodeNotFound: boolean;
    isInvalidFEOpcode: boolean;
    isInvalidJump: boolean;
    isNotActivated: boolean;
    isStackUnderflow: boolean;
    isStackOverflow: boolean;
    isOutOfOffset: boolean;
    isCreateCollision: boolean;
    isPrecompileError: boolean;
    isNonceOverflow: boolean;
    isCreateContractSizeLimit: boolean;
    isCreateContractStartingWithEF: boolean;
    isCreateInitCodeSizeLimit: boolean;
    successStr: string;
    errorStr: string;
    reasonStr: string;
};
//# sourceMappingURL=hardhat.d.ts.map