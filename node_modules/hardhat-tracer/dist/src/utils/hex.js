"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.memorySlice = exports.toAddr = exports.shallowCopyStack2 = exports.shallowCopyStack = exports.parseMemory = exports.parseBytes32 = exports.parseAddress = exports.parseUint = exports.parseNumber = exports.hexPrefix = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
/**
 * Ensures 0x prefix to a hex string which may or may not
 * @param str A hex string that may or may not have 0x prepended
 */
function hexPrefix(str) {
    return !str.startsWith("0x") ? "0x" + str : str;
}
exports.hexPrefix = hexPrefix;
function parseNumber(str) {
    return parseUint(str).toNumber();
}
exports.parseNumber = parseNumber;
function parseUint(str) {
    return ethers_1.BigNumber.from(hexPrefix(str));
}
exports.parseUint = parseUint;
function parseAddress(str) {
    return (0, utils_1.hexZeroPad)((0, utils_1.hexStripZeros)(hexPrefix(str)), 20);
}
exports.parseAddress = parseAddress;
function parseBytes32(str) {
    return (0, utils_1.hexZeroPad)((0, utils_1.hexStripZeros)(hexPrefix(str)), 32);
}
exports.parseBytes32 = parseBytes32;
function parseMemory(strArr) {
    return (0, utils_1.arrayify)(hexPrefix(strArr.join("")));
}
exports.parseMemory = parseMemory;
function shallowCopyStack(stack) {
    return [...stack];
}
exports.shallowCopyStack = shallowCopyStack;
function shallowCopyStack2(stack) {
    return [...stack].map((x) => ethers_1.BigNumber.from(x).toHexString());
}
exports.shallowCopyStack2 = shallowCopyStack2;
function toAddr(val) {
    return (0, utils_1.hexZeroPad)((0, utils_1.hexlify)(val), 20);
}
exports.toAddr = toAddr;
function memorySlice(buffer, offset, length) {
    if (!buffer) {
        throw new Error("memory is undefined");
    }
    if (offset !== undefined && length !== undefined) {
        return (0, utils_1.hexDataSlice)(buffer, offset, offset + length);
    }
    else {
        return "0x";
    }
}
exports.memorySlice = memorySlice;
//# sourceMappingURL=hex.js.map