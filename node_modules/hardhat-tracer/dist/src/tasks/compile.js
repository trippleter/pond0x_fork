"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const config_1 = require("hardhat/config");
const utils_1 = require("../utils");
const debug = (0, debug_1.default)("hardhat-tracer:tasks:compile");
(0, config_1.task)(task_names_1.TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS).setAction(async (args, hre, runSuper) => {
    const result = await runSuper(args);
    debug("running post compile actions");
    // if artifacts are updated after compilation step, then update the decoder
    if (hre.tracer.decoder) {
        debug("updating artifacts...");
        hre.tracer.decoder
            .updateArtifacts(hre.artifacts)
            .then(() => debug("artifacts updated successfully!"))
            .catch((e) => {
            debug("error updating artifacts %s", e.message);
            console.log("[hardhat-tracer]: error while updating decoder artifacts after TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS: " +
                e.message);
        });
    }
    // if state overrides are provided, then apply them after compilation
    if (hre.tracer.stateOverrides && hre.tracer.recorder?.vm) {
        debug("applying state overrides...");
        (0, utils_1.applyStateOverrides)(hre.tracer.stateOverrides, hre.tracer.recorder?.vm, hre.artifacts)
            .then(() => debug("state overrides applied successfully!"))
            .catch((e) => {
            debug("error applying state overrides %s", e.message);
            console.log("[hardhat-tracer]: error while applying state overrides after TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS: " +
                e.message);
        });
    }
    return result;
});
//# sourceMappingURL=compile.js.map