"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const config_1 = require("hardhat/config");
const cache_1 = require("../cache");
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const debug = (0, debug_1.default)("hardhat-tracer:extend:config");
(0, config_1.extendConfig)((config, _userConfig) => {
    debug("extending config...");
    const userConfigTracer = _userConfig.tracer || {};
    const opcodes = new Map();
    // always active opcodes
    const opcodesToActivate = [];
    if (userConfigTracer?.opcodes) {
        if (!Array.isArray(userConfigTracer.opcodes)) {
            throw new Error("[hardhat-tracer]: tracer.opcodes in hardhat user config should be array");
        }
        opcodesToActivate.push(...userConfigTracer.opcodes);
    }
    for (const opcode of opcodesToActivate) {
        opcodes.set(opcode, true);
    }
    const cache = new cache_1.TracerCache();
    cache.setCachePath(config.paths.cache);
    cache.load();
    // NOTE: config that will be mutable should be cloned, since userConfig is immutable
    config.tracer = {
        enabled: userConfigTracer?.enabled ?? false,
        ignoreNext: false,
        printNext: false,
        verbosity: userConfigTracer?.defaultVerbosity ?? constants_1.DEFAULT_VERBOSITY,
        showAddresses: userConfigTracer?.showAddresses ?? true,
        gasCost: userConfigTracer?.gasCost ?? false,
        enableAllOpcodes: userConfigTracer?.enableAllOpcodes ?? false,
        use4bytesDirectory: userConfigTracer?.use4bytesDirectory ?? true,
        opcodes,
        nameTags: { ...(userConfigTracer?.nameTags ?? {}) },
        printMode: "console",
        _internal: {
            printNameTagTip: undefined,
            cache,
        },
        lastTrace() {
            if (this.recorder) {
                return this.recorder.previousTraces[this.recorder.previousTraces.length - 1];
            }
        },
        stateOverrides: userConfigTracer?.stateOverrides, // immutable
    };
    if (userConfigTracer?.tasks) {
        if (!Array.isArray(userConfigTracer?.tasks)) {
            throw new Error("[hardhat-tracer]: tracer.tasks in hardhat user config should be array");
        }
        for (const taskName of userConfigTracer?.tasks) {
            if (typeof taskName !== "string") {
                throw new Error("[hardhat-tracer]: tracer.tasks in hardhat user config should be array of strings");
            }
            (0, utils_1.registerTask)(taskName);
        }
    }
    debug("config extended!");
});
//# sourceMappingURL=config.js.map